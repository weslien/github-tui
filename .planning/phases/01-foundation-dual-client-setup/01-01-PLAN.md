---
phase: 01-foundation-dual-client-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - github/client.go
  - github/rate_limiter.go
  - github/rate_limiter_test.go
autonomous: true

must_haves:
  truths:
    - "REST client initializes with same PAT token as GraphQL client"
    - "Rate limiter wraps HTTP transport for both REST and GraphQL traffic"
    - "REST rate limit headers (X-RateLimit-*) are parsed and tracked after each response"
    - "GraphQL and REST rate limits are tracked independently"
    - "Concurrent request limit (90 conservative) prevents exceeding GitHub's 100-request cap"
  artifacts:
    - path: "github/rate_limiter.go"
      provides: "RateLimiter type with RoundTripper middleware, independent REST/GraphQL tracking, concurrent semaphore"
      exports: ["RateLimiter", "NewRateLimiter", "rateLimitTransport"]
    - path: "github/rate_limiter_test.go"
      provides: "Tests for rate limiter transport detection, header parsing, concurrent semaphore"
      contains: "func Test"
    - path: "github/client.go"
      provides: "Dual client initialization sharing OAuth2 http.Client with rate-limiting transport"
      exports: ["NewClient", "GetRESTClient"]
  key_links:
    - from: "github/client.go"
      to: "github/rate_limiter.go"
      via: "NewRateLimiter() called during NewClient(), WrapTransport wraps OAuth2 transport"
      pattern: "NewRateLimiter|WrapTransport"
    - from: "github/rate_limiter.go"
      to: "net/http"
      via: "rateLimitTransport implements http.RoundTripper"
      pattern: "RoundTrip.*\\*http\\.Request"
---

<objective>
Add google/go-github REST client alongside existing GraphQL client with shared OAuth2 transport, and implement a unified rate limiter as http.RoundTripper middleware that tracks REST and GraphQL rate limits independently.

Purpose: Phase 2 (Actions) requires REST API access for workflow logs. Phase 3 (Projects V2) needs GraphQL. Both need rate limiting to avoid throttling. This plan establishes the transport-level infrastructure both depend on.

Output: `github/rate_limiter.go` (RateLimiter + RoundTripper), updated `github/client.go` (dual client init), `github/rate_limiter_test.go` (tests), updated `go.mod`/`go.sum`.
</objective>

<execution_context>
@/Users/gustav/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gustav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-dual-client-setup/01-RESEARCH.md

Key existing files:
@github/client.go
@ui/ui.go
@cmd/ght/main.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add go-github dependency and refactor client.go for dual client initialization</name>
  <files>go.mod, go.sum, github/client.go</files>
  <action>
1. Install dependencies:
   ```bash
   cd /Users/gustav/src/github-tui
   go get github.com/google/go-github/v68@latest
   go get golang.org/x/time/rate@latest
   ```
   Note: Research recommended v83 but use the latest available stable version. If v83 is not found, try v68 or check `go list -m -versions github.com/google/go-github/v83` first.

2. Refactor `github/client.go`:
   - Keep the existing `var client *githubv4.Client` (rename to `graphQLClient` for clarity)
   - Add `var restClient *github.Client` (from google/go-github)
   - Add `var rateLimiter *RateLimiter` (will be implemented in Task 2; for now, declare the var)
   - Refactor `NewClient(token string)` to:
     a. Create `oauth2.StaticTokenSource` with the token
     b. Create `oauth2.NewClient(ctx, ts)` as the base HTTP client
     c. Store the base httpClient for later rate limiter wrapping (will be wired in Plan 02)
     d. Initialize `graphQLClient = githubv4.NewClient(httpClient)` (existing behavior preserved)
     e. Initialize `restClient = github.NewClient(httpClient)` (NEW)
   - Add `func GetRESTClient() *github.Client` accessor
   - Add `func GetGraphQLClient() *githubv4.Client` accessor (for consistency)
   - Update all existing functions that reference `client` to use `graphQLClient` instead

3. Verify all existing functions still compile and work by running:
   ```bash
   go build ./...
   ```

IMPORTANT: Do NOT wire the rate limiter into the transport yet — that happens in Plan 02 after both pieces exist. For now, just add the `rateLimiter` var declaration and leave it nil.

All existing query/mutation functions (GetIssues, CreateIssue, etc.) must continue to work unchanged — they just reference `graphQLClient` instead of `client`.
  </action>
  <verify>
- `go build ./...` succeeds with no errors
- `go vet ./...` passes
- `github/client.go` exports both `GetRESTClient()` and `GetGraphQLClient()`
- All existing functions reference `graphQLClient` (not bare `client`)
- `go.mod` includes `github.com/google/go-github` and `golang.org/x/time`
  </verify>
  <done>
- go-github and x/time/rate are in go.mod
- `NewClient()` initializes both REST and GraphQL clients with shared OAuth2 token
- All existing API functions still compile and reference the renamed graphQLClient
- `GetRESTClient()` returns non-nil *github.Client after `NewClient()` is called
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement unified rate limiter with http.RoundTripper middleware and tests</name>
  <files>github/rate_limiter.go, github/rate_limiter_test.go</files>
  <action>
1. Create `github/rate_limiter.go` with:

   **RateLimiter struct:**
   - `restLimiter *rate.Limiter` — 5000 req/hr = ~1.39 req/sec, burst 10
   - `graphQLLimiter *rate.Limiter` — 5000 pts/hr = ~1.39 req/sec, burst 10
   - `concurrentSem chan struct{}` — buffered channel capacity 90 (conservative vs GitHub's 100 limit)
   - `mu sync.RWMutex` protecting mutable state
   - `restRemaining int`, `restLimit int` — parsed from X-RateLimit-* headers
   - `graphQLRemaining int`, `graphQLLimit int` — parsed from response body (tracked but NOT parsed in RoundTripper — see note below)
   - `restResetAt time.Time` — parsed from X-RateLimit-Reset header

   **NewRateLimiter() *RateLimiter** — constructor with defaults

   **WrapTransport(base http.RoundTripper) http.RoundTripper** — returns `rateLimitTransport`

   **rateLimitTransport struct:**
   - `base http.RoundTripper`
   - `rl *RateLimiter`

   **rateLimitTransport.RoundTrip(req *http.Request) (*http.Response, error):**
   - Acquire concurrent semaphore slot (blocks if 90 in flight)
   - Detect if GraphQL: `req.URL.Path == "/graphql"` and `req.Method == "POST"`
   - Wait on appropriate rate.Limiter (graphQLLimiter or restLimiter) with request context
   - Call `base.RoundTrip(req)`
   - Release semaphore in defer
   - For REST responses: parse `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers and update state
   - For GraphQL responses: Do NOT parse response body in RoundTripper (would consume the body). GraphQL rate limit tracking will be handled at the query level in Phase 2/3 by adding RateLimit field to queries. For now, just track via the pre-request rate.Limiter.
   - Return response

   **GetRESTStats() (remaining, limit int, resetAt time.Time)** — thread-safe accessor
   **GetGraphQLStats() (remaining, limit int)** — thread-safe accessor
   **IsApproachingLimit(threshold float64) (rest bool, graphql bool)** — returns true if remaining < threshold * limit (e.g., 0.1 for 10%)

2. Create `github/rate_limiter_test.go` with table-driven tests:

   a. **TestRateLimitTransport_DetectsGraphQL**: Verify that POST to `/graphql` is detected as GraphQL, GET to `/repos/...` is detected as REST
   b. **TestRateLimitTransport_ParsesRESTHeaders**: Create a mock RoundTripper that returns X-RateLimit-* headers. Verify `GetRESTStats()` returns parsed values after a request.
   c. **TestRateLimitTransport_ConcurrentSemaphore**: Verify that more than 90 concurrent requests block (use goroutines + sync.WaitGroup). This test should:
      - Create a slow mock transport (sleeps 100ms)
      - Launch 91 goroutines making requests
      - Verify the 91st blocks until one completes
   d. **TestIsApproachingLimit**: Verify threshold calculation with different remaining/limit values

   Use `net/http/httptest` for mock servers where needed.

IMPORTANT: Do NOT use io.TeeReader or parse GraphQL response bodies in the RoundTripper. The research identified this as an open question — the clean solution is to add `RateLimit` fields to GraphQL query structs later. The RoundTripper only handles REST header parsing and the pre-request rate limiting via x/time/rate for both clients.
  </action>
  <verify>
- `go build ./...` succeeds
- `go test -race ./github/...` passes all tests
- `go vet ./...` passes
- Rate limiter correctly detects GraphQL vs REST requests
- REST headers are parsed and accessible via GetRESTStats()
- Concurrent semaphore limits to 90 in-flight requests
  </verify>
  <done>
- `github/rate_limiter.go` exists with RateLimiter, rateLimitTransport, header parsing, concurrent semaphore
- `github/rate_limiter_test.go` passes with -race flag
- REST rate limit headers are parsed and tracked
- GraphQL rate limiting uses pre-request rate.Limiter (body parsing deferred)
- Concurrent requests capped at 90 via semaphore
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/gustav/src/github-tui
go build ./...
go test -race ./github/...
go vet ./...
```

All three commands must pass with zero errors. The existing application behavior is preserved — `NewClient()` initializes both clients, and all existing GraphQL functions continue to work.
</verification>

<success_criteria>
1. `go.mod` includes google/go-github and golang.org/x/time as dependencies
2. `github/client.go` initializes both REST and GraphQL clients with the same OAuth2 token
3. `github/rate_limiter.go` implements http.RoundTripper middleware with independent tracking
4. Rate limiter tests pass with -race flag
5. All existing GraphQL functions still compile and reference renamed client
6. `go build ./...` and `go vet ./...` pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-dual-client-setup/01-01-SUMMARY.md`
</output>
