---
phase: 01-foundation-dual-client-setup
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - github/token_validator.go
  - github/token_validator_test.go
  - github/client.go
  - cmd/ght/main.go
autonomous: true

must_haves:
  truths:
    - "App validates PAT token scopes on startup before launching UI"
    - "App fails fast with clear error message listing missing scopes if required scopes are absent"
    - "App handles both classic PATs (X-OAuth-Scopes header) and fine-grained PATs (empty header) gracefully"
    - "Rate limiter is wired into the shared HTTP transport so all API calls go through it"
    - "Rate limit stats are accessible for future UI display (Phase 2/3)"
  artifacts:
    - path: "github/token_validator.go"
      provides: "Token scope validation via X-OAuth-Scopes header with fine-grained PAT fallback"
      exports: ["ValidateTokenScopes", "TokenScopes"]
    - path: "github/token_validator_test.go"
      provides: "Tests for scope parsing, classic PAT detection, fine-grained PAT handling, missing scope errors"
      contains: "func Test"
    - path: "cmd/ght/main.go"
      provides: "Startup sequence: config -> client init -> token validation -> UI"
      contains: "ValidateTokenScopes"
    - path: "github/client.go"
      provides: "Rate limiter wired into shared transport"
      contains: "WrapTransport"
  key_links:
    - from: "cmd/ght/main.go"
      to: "github/token_validator.go"
      via: "ValidateTokenScopes called after NewClient, before ui.Start"
      pattern: "github\\.ValidateTokenScopes"
    - from: "github/client.go"
      to: "github/rate_limiter.go"
      via: "WrapTransport wraps OAuth2 transport during NewClient"
      pattern: "WrapTransport"
    - from: "github/token_validator.go"
      to: "net/http"
      via: "GET /user with Bearer token to read X-OAuth-Scopes header"
      pattern: "X-OAuth-Scopes"
---

<objective>
Implement token scope validation on startup and wire the rate limiter into the client transport layer so all API calls are rate-limited. Token validation checks required scopes (repo, actions, project) via the X-OAuth-Scopes header for classic PATs and degrades gracefully for fine-grained PATs.

Purpose: Users get immediate feedback if their PAT is missing required scopes rather than encountering cryptic 403 errors later. Rate limiter wiring ensures all REST and GraphQL traffic is tracked from first request.

Output: `github/token_validator.go`, `github/token_validator_test.go`, updated `github/client.go` (rate limiter wiring), updated `cmd/ght/main.go` (validation in startup).
</objective>

<execution_context>
@/Users/gustav/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gustav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-dual-client-setup/01-RESEARCH.md
@.planning/phases/01-foundation-dual-client-setup/01-01-SUMMARY.md

Key existing files:
@github/client.go
@github/rate_limiter.go
@cmd/ght/main.go
@config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token scope validator with tests</name>
  <files>github/token_validator.go, github/token_validator_test.go</files>
  <action>
1. Create `github/token_validator.go`:

   **TokenScopes struct:**
   - `Scopes []string` — raw scopes from X-OAuth-Scopes header
   - `HasRepo bool` — `repo` scope present (includes Actions access)
   - `HasProject bool` — `project` or `read:org` scope present
   - `IsClassicPAT bool` — true if X-OAuth-Scopes header was present (classic PAT)
   - `IsFineGrained bool` — true if X-OAuth-Scopes header was empty/missing (fine-grained PAT)

   **ValidateTokenScopes(ctx context.Context, token string) (*TokenScopes, error):**
   - Make `GET https://api.github.com/user` with `Authorization: Bearer {token}` header
   - Use the passed context for timeout control
   - If status != 200: return error with status code ("token validation failed: HTTP %d — check that your token is valid")
   - Read `X-OAuth-Scopes` response header
   - If header is non-empty: parse comma-separated scopes, set `IsClassicPAT = true`, populate Has* booleans
   - If header is empty/missing: set `IsFineGrained = true`, log a warning that scope validation is skipped for fine-grained PATs
   - Return *TokenScopes

   **Scope detection logic (classic PATs):**
   - `repo` scope implies: repo access + Actions access (GitHub bundles Actions under repo)
   - `project` scope OR `read:org` scope: needed for Projects V2
   - `admin:org` scope implies: project access

   **(ts *TokenScopes) MissingScopes() []string:**
   - Return list of missing required scopes for display
   - Required: "repo" (for issues + actions), "project or read:org" (for Projects V2)
   - If `IsFineGrained`: return nil (cannot validate fine-grained PATs via header)

   **(ts *TokenScopes) Validate() error:**
   - Call MissingScopes()
   - If any missing: return `fmt.Errorf("missing required token scopes: %s\n\nYour token needs: repo, project (or read:org)\nSee: https://github.com/settings/tokens", strings.Join(missing, ", "))`
   - If fine-grained PAT: log warning but return nil (degrade gracefully — let API calls fail with clear errors if permissions are actually missing)

2. Create `github/token_validator_test.go` with table-driven tests:

   a. **TestValidateTokenScopes_ClassicPAT_AllScopes**: Mock server returns `X-OAuth-Scopes: repo, project` header. Verify HasRepo=true, HasProject=true, IsClassicPAT=true, Validate() returns nil.

   b. **TestValidateTokenScopes_ClassicPAT_MissingProject**: Mock server returns `X-OAuth-Scopes: repo`. Verify HasRepo=true, HasProject=false, MissingScopes contains "project or read:org".

   c. **TestValidateTokenScopes_ClassicPAT_MissingRepo**: Mock server returns `X-OAuth-Scopes: project`. Verify MissingScopes contains "repo".

   d. **TestValidateTokenScopes_FineGrainedPAT**: Mock server returns no X-OAuth-Scopes header. Verify IsFineGrained=true, Validate() returns nil (graceful degradation).

   e. **TestValidateTokenScopes_InvalidToken**: Mock server returns 401. Verify error is returned.

   f. **TestValidateTokenScopes_RepoImpliesActions**: Verify that `repo` scope sets HasRepo=true (since GitHub bundles Actions under repo scope).

   g. **TestValidateTokenScopes_ReadOrgImpliesProject**: Verify that `read:org` scope sets HasProject=true.

   Use `net/http/httptest.NewServer` for all mock servers. Each test creates its own server with specific response headers.
  </action>
  <verify>
- `go build ./github/...` succeeds
- `go test -race -v ./github/...` passes all token_validator tests
- `go vet ./github/...` passes
- Classic PAT with all scopes: Validate() returns nil
- Classic PAT with missing scopes: Validate() returns descriptive error
- Fine-grained PAT: Validate() returns nil with log warning
  </verify>
  <done>
- `github/token_validator.go` exports ValidateTokenScopes and TokenScopes
- Tests cover: all scopes present, missing scopes, fine-grained PAT fallback, invalid token, scope implication rules
- Validate() provides clear error messages listing exactly which scopes are missing
- Fine-grained PATs degrade gracefully (warn but don't block)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire rate limiter into client transport and add token validation to startup</name>
  <files>github/client.go, cmd/ght/main.go</files>
  <action>
1. Update `github/client.go` — Wire rate limiter into transport:
   - In `NewClient(token string)`:
     a. After creating `httpClient := oauth2.NewClient(ctx, ts)`, create the rate limiter:
        `rateLimiter = NewRateLimiter()`
     b. Wrap the OAuth2 transport:
        `httpClient.Transport = rateLimiter.WrapTransport(httpClient.Transport)`
     c. Then pass the wrapped httpClient to both `githubv4.NewClient(httpClient)` and `github.NewClient(httpClient)`
   - Add `func GetRateLimiter() *RateLimiter` accessor so UI/main.go can check stats

2. Update `cmd/ght/main.go` — Add token validation to startup:
   - After `github.NewClient(config.GitHub.Token)`:
     a. Create a context with 10-second timeout: `ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)`
     b. Call `scopes, err := github.ValidateTokenScopes(ctx, config.GitHub.Token)`
     c. cancel() the context
     d. If err != nil: `log.Fatalf("Token validation failed: %v", err)`
     e. If `scopes.Validate()` returns err: `log.Fatalf("Token scope check failed: %v", err)`
     f. If `scopes.IsFineGrained`: `log.Println("Note: Fine-grained PAT detected — scope validation skipped. If you encounter permission errors, verify your token has repo, actions, and project read permissions.")`
   - The startup sequence should be: config.Init() -> getRepoInfo() -> github.NewClient() -> token validation -> ui.New().Start()

3. Verify the full application builds and the startup sequence is correct:
   ```bash
   go build ./...
   go vet ./...
   ```

IMPORTANT: The `ValidateTokenScopes` function makes its own HTTP request (not through the rate-limited client) because it runs before the rate limiter state matters and needs direct header access. This is intentional per the research recommendations.
  </action>
  <verify>
- `go build ./...` succeeds
- `go vet ./...` passes
- `go test -race ./github/...` passes (existing + new tests)
- `github/client.go` has `rateLimiter.WrapTransport` call in NewClient
- `cmd/ght/main.go` calls ValidateTokenScopes before ui.Start
- GetRateLimiter() returns non-nil after NewClient() call
  </verify>
  <done>
- Rate limiter wraps the shared HTTP transport — all REST and GraphQL calls go through it
- Token scope validation runs on startup with 10-second timeout
- Classic PATs with missing scopes cause immediate fatal error with helpful message
- Fine-grained PATs log a warning but allow the app to continue
- Full `go build ./...` and `go test -race ./...` pass
- GetRateLimiter() accessor is available for future rate limit display
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/gustav/src/github-tui
go build ./...
go test -race ./github/...
go test -race ./...
go vet ./...
```

All commands must pass. Additionally verify the wiring by inspecting:
- `github/client.go` contains `WrapTransport` call
- `cmd/ght/main.go` calls `ValidateTokenScopes` before `ui.New().Start()`
- Rate limiter is created and wired in `NewClient()` before either client is constructed
</verification>

<success_criteria>
1. Token scope validation runs before UI starts — missing scopes cause clear fatal error
2. Fine-grained PATs handled gracefully with warning log (no false positive failures)
3. Rate limiter wraps shared transport — all API calls flow through RoundTripper middleware
4. GetRateLimiter() provides access to rate limit stats for future UI display
5. All tests pass with -race flag
6. Full build succeeds with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-dual-client-setup/01-02-SUMMARY.md`
</output>
